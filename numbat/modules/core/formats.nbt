use core::strings
use core::strings::extra
use core::functions
use math::number_theory

let _empty_str = ""
let _period_str = "."
let _zero_str = "0"

fn _remove_trailing_zeroes(s: String) -> String = 
  if !str_contains(s, ".")
  then s
  else if last_char == "0"
    then (str_slice(s, 0, s_length - 1) |> _remove_trailing_zeroes)
  else if last_char == "."
    then str_slice(s, 0, s_length - 1)
  else s
  where s_length = str_length(s)
    and last_char = str_slice(s, s_length - 1, s_length)

@description("Formats value as an ordinary decimal number")
@example("fmt_decimal(1234.56)")
fn fmt_decimal<A>(value: A) -> String = join(tail(parts) |> cons(str_replace(out_str, "_", "")), " ")
    where str: String = "{value}"
      and parts: List<String> = str_split(" ", str)
      and value_str: String = head(parts)
      and value_str_parts = str_split("e", value_str)
      and value_str_value_part = head(value_str_parts)
      and decimal_index = str_find(value_str_value_part, ".")
      and decimal_count: Scalar = str_length(value_str_value_part) - (if decimal_index != -1 then decimal_index + 1 else str_length(value_str_value_part))
      and out_str: String = if !str_contains(value_str, "e") 
        then value_str
        else if !str_contains(value_str, "e-")
          then "{str_replace(value_str_value_part, _period_str, _empty_str)}{str_repeat(_zero_str, parse_int(head(tail(value_str_parts))) - decimal_count)}"
          else "0.{str_repeat(_zero_str, (-parse_int(head(tail(value_str_parts)))) - 1)}{str_replace(value_str_value_part, _period_str, _empty_str)}" |>
          _remove_trailing_zeroes

fn _remove_leading_zeroes(s: String) -> String = 
  if str_find(s, "0") == 0
    then (str_slice(s, 1, str_length(s)) |> _remove_leading_zeroes)
  else if str_find(s, ".") == 0
    then str_append("0", s)
  else s

fn _get_exponent<A: Dim>(value: A) -> Scalar =
  if str_find(value_str, "0") != 0
    then
      if str_contains(value_str, "." ) 
        then str_find(value_str, ".") - 1
        else str_length(value_str) - 1
    else (str_length(trimmed_decimal_value_str)) - (str_length(value_str) - 1)
  where clean_str: String = fmt_decimal(value)
    and parts: List<String> = clean_str |> str_split(" ")
    and value_str: String = head(parts)
    and trimmed_decimal_value_str = str_slice(head(parts), 2, str_length(head(parts))) |> _remove_leading_zeroes  

fn _fmt_science<A: Dim>(value: A) -> String = 
  if str_contains(value_str, "e")
    then clean_str
    else join(cons(str_append(output_value_str, exponent_str), tail(parts)), " ")
  where clean_str: String = fmt_decimal(value)
    and parts: List<String> = clean_str |> str_split(" ")
    and value_str: String = head(parts)
    and exponent:  Scalar = _get_exponent(value)
    and new_value_str: String = str_replace("{value * 10^(-exponent)}", str_append(" ", join(tail(parts), " ")), "")
    and output_value_str: String = if str_contains(new_value_str, "." ) then new_value_str else "{new_value_str}.0"
    and exponent_str: String = if exponent >= 0 then "e+{exponent}" else "e{exponent}"

@description("Formats value in scientific notation")
@example("fmt_science(1234.56)")
@example("fmt_science(0.000123456)")
fn fmt_science<A: Dim>(value: A) -> String = 
  if value < 0 
  then "-{_fmt_science(abs(value))}" 
  else _fmt_science(value)


struct Fraction {
  numerator: Scalar,
  denominator: Scalar,
}


fn _get_as_fraction(value: Scalar) -> Fraction = 
  if decimal_index == -1
    then Fraction { numerator: value, denominator: 1 }
    else Fraction { numerator: numerator, denominator: denominator}
  where value_str = fmt_decimal(value)
    and decimal_index = str_find(value_str, ".")
    and offset = 10^(str_length(value_str) - (decimal_index + 1))
    and offset_value = value * offset
    and value_gcd = gcd(offset_value, offset)
    and numerator = offset_value / value_gcd
    and denominator = offset / value_gcd

@description("Formats value to be represented as a fraction which may have a numerator larger than its denominator")
@example("fmt_improper_fraction(1234.56)")
@example("fmt_improper_fraction(0.000123456)")
fn fmt_improper_fraction(value: Scalar) -> String = 
  if decimal_index == -1
    then str_append(value_str, "/1")
    else "{numerator}/{denominator}"
  where value_str = fmt_decimal(value)
    and decimal_index = str_find(value_str, ".")
    and offset = 10^(str_length(value_str) - (decimal_index + 1))
    and offset_value = value * offset
    and value_gcd = gcd(value_of(offset_value), offset)
    and numerator = offset_value / value_gcd |> fmt_decimal
    and denominator = offset / value_gcd |> fmt_decimal

@description("Formats value to be represented as an integer potentially followed by a fractionfraction")
@example("fmt_fraction(1234.56)")
@example("fmt_fraction(0.000123456)")
fn fmt_fraction(value: Scalar) -> String = 
  if !str_contains(value_str, ".")
    then value_str
    else join(cons(output_value_str, tail(parts)), " ") 
  where value_str = fmt_decimal(value)
    and parts = value_str |> str_split(" ")
    and value_part = head(parts)
    and value_decimal_parts = value_part |> str_split(".")
    and value_decimal_part = value_decimal_parts |> head
    and fraction: Fraction = _get_as_fraction(value_of(value))
    and output_value_str = 
      if value_decimal_part != "0" && value_decimal_part != ""
        then "{value_decimal_part} + {mod(fraction.numerator, fraction.denominator)}/{fraction.denominator}"
        else "{mod(fraction.numerator, fraction.denominator)}/{fraction.denominator}"
